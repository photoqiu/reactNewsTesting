1、网络优化：

```html
<meta http-equiv="x-dns-prefetch-control" content="on" />
<link rel="dns-prefetch" href="http://dns.jd.com" />
```

1.1使用npm 对 三方开发公共包进行优化和管理：

```javascript
npm dedupe
```

1.2 npm依赖管理之peerDependencies
peerDependencies的目的是提示宿主环境去安装满足插件peerDependencies所指定依赖的包，然后在插件import或者require所依赖的包的时候，永远都是引用宿主环境统一安装的npm包，最终解决插件与所依赖包不一致的问题。

npm2中出现依赖，会主动安装依赖，npm3中不会再要求peerDependencies所指定的依赖包被强制安装，相反npm3会在安装结束后检查本次安装是否正确，如果不正确会给用户打印警告提示。





1.3 Webpack5 新特性 - 模块联邦

真正 Runtime 的方式可能是 UMD 方式共享代码模块，即将模块用 Webpack UMD 模式打包，并输出到其他项目中。

```javascript
const ModuleFederationPlugin = require("webpack/lib/container/ModuleFederationPlugin");
```

使用方式如下：

```javascript
const HtmlWebpackPlugin = require("html-webpack-plugin");
const ModuleFederationPlugin = require("webpack/lib/container/ModuleFederationPlugin");

module.exports = {
  // other webpack configs...
  plugins: [
    new ModuleFederationPlugin({
      name: "app_one_remote",
      remotes: {
        app_two: "app_two_remote",
        app_three: "app_three_remote"
      },
      exposes: {
        AppContainer: "./src/App"
      },
      shared: ["react", "react-dom", "react-router-dom"]
    }),
    new HtmlWebpackPlugin({
      template: "./public/index.html",
      chunks: ["main"]
    })
  ]
};
```

模块联邦本身是一个普通的 Webpack 插件 ModuleFederationPlugin，插件有几个重要参数：

1. name 当前应用名称，需要全局唯一。
2. remotes 可以将其他项目的 name 映射到当前项目中。
3. exposes 表示导出的模块，只有在此申明的模块才可以作为远程依赖被使用。
4. shared 是非常重要的参数，制定了这个参数，可以让远程加载的模块对应依赖改为使用本地项目的 React 或 ReactDOM。

2、CSS优化技巧：

#### content-visibility （实验性属性，非所有浏览器支持）

内容可见性，加速渲染：content-visibility，渲染性能可以大幅提升

content-visibility: auto; 默认属性

#### will-change（移动端，所有浏览器支持）

虽然说will-change能提高性能，但这个属性应该被认为是最后的手段，它不是为了过早的优化。只有消退你必须处理性能问题时，你才应该使用它。如果你滥用的话，反而会降低Web的性能。比如：

使用will-change表示该元素在未来会发生变化。

因此，如果你试图将will-change和动画同时使用，它将不会给你带来优化。因此，建议在父元素上使用will-change，在子元素上使用动画。

在实际使用will-change可以记作以下几个规则，即 五可做，三不可做：

在样式表中少用will-change

给will-change足够的时间令其发挥该有的作用

使用<custom-ident>来针对超特定的变化（如，left, opacity等）

如果需要的话，可以JavaScript中使用它（添加和删除）

修改完成后，删除will-change

不要同时声明太多的属性

不要应用在太多元素上

不要把资源浪费在已停止变化的元素上

详细的使用，请参阅：

CSS Will Change Module Level 1

https://www.w3.org/TR/css-will-change-1/

Everything You Need to Know About the CSS will-change Property

https://dev.opera.com/articles/css-will-change-property/

CSS Reference：will-change

https://tympanus.net/codrops/css_reference/will-change/

#### scroll-behavior（所有浏览器支持）

scroll-behavior是CSSOM View Module提供的一个新特性，可以轻易的帮助我们实现丝滑般的滚动效果。该属性可以为一个滚动框指定滚动行为，其他任何的滚动，例如那些由于用户行为而产生的滚动，不受这个属性的影响。

scroll-behavior接受两个值：

auto ：滚动框立即滚动

smooth ：滚动框通过一个用户代理定义的时间段使用定义的时间函数来实现平稳的滚动，用户代理平台应遵循约定，如果有的话

除此之外，其还有三个全局的值：inherit、initial和unset。

使用起来很简单，只需要这个元素上使用scroll-behavior:smooth。因此，很多时候为了让页面滚动更平滑，建议在html中直接这样设置一个样式：

```css
html {
  scroll-behavior:smooth;
}
```

有关于scroll-behavior属性更多的介绍可以再花点时间阅读下面这些文章：

CSSOM View Module:scroll-behavior

CSS-Tricks: scroll-behavior

Native Smooth Scroll behavior

PAGE SCROLLING IN VANILLA JAVASCRIPT

smooth scroll behavior polyfill



3、JavaScript语法糖：

1. #### 含有多个条件的 if 语句

```javascript
//longhand
if (x === 'abc' || x === 'def' || x === 'ghi' || x ==='jkl') {
  //logic
}
可以简写如下：
//shorthand
if (['abc', 'def', 'ghi', 'jkl'].includes(x)) {
  //logic
}
```

2. #### 同时为多个变量赋值

   当我们处理多个变量，并且需要对这些变量赋不同的值，这种缩写法很有用。

```javascript
//Longhand 
let test1, test2, test3;
test1 = 1;
test2 = 2;
test3 = 3;

//Shorthand 
let [test1, test2, test3] = [1, 2, 3];
```

3. #### switch 对应的缩写法

  我们可以把条件值保存在名值对中，基于这个条件使用名值对代替 switch。
```javascript
// Longhand
switch (data) {
  case 1:
    test1();
  break;
  case 2:
    test2();
  break;
  case 3:
    test();
  break;
  // And so on...
}

// Shorthand
var data = {
  1: test1,
  2: test2,
  3: test
};
data[something] && data[something]();
```

4. #### Array.find 缩写法

  当我们需要在一个对象数组中按属性值查找特定对象时，find 方法很有用。
```javascript
const data = [{
        type: 'test1',
        name: 'abc'
    },
    {
        type: 'test2',
        name: 'cde'
    },
    {
        type: 'test1',
        name: 'fgh'
    },
]
function findtest1(name) {
    for (let i = 0; i < data.length; ++i) {
        if (data[i].type === 'test1' && data[i].name === name) {
            return data[i];
        }
    }
}
//Shorthand
filteredData = data.find(data => data.type === 'test1' && data.name === 'fgh');
console.log(filteredData); // { type: 'test1', name: 'fgh' }
```

