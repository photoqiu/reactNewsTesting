1、网络优化：

```html
<meta http-equiv="x-dns-prefetch-control" content="on" />
<link rel="dns-prefetch" href="http://dns.jd.com" />
```

1.1使用npm 对 三方开发公共包进行优化和管理：

```javascript
npm dedupe
```

1.2 npm依赖管理之peerDependencies
peerDependencies的目的是提示宿主环境去安装满足插件peerDependencies所指定依赖的包，然后在插件import或者require所依赖的包的时候，永远都是引用宿主环境统一安装的npm包，最终解决插件与所依赖包不一致的问题。

npm2中出现依赖，会主动安装依赖，npm3中不会再要求peerDependencies所指定的依赖包被强制安装，相反npm3会在安装结束后检查本次安装是否正确，如果不正确会给用户打印警告提示。





1.3 Webpack5 新特性 - 模块联邦

真正 Runtime 的方式可能是 UMD 方式共享代码模块，即将模块用 Webpack UMD 模式打包，并输出到其他项目中。

```javascript
const ModuleFederationPlugin = require("webpack/lib/container/ModuleFederationPlugin");
```

使用方式如下：

```javascript
const HtmlWebpackPlugin = require("html-webpack-plugin");
const ModuleFederationPlugin = require("webpack/lib/container/ModuleFederationPlugin");

module.exports = {
  // other webpack configs...
  plugins: [
    new ModuleFederationPlugin({
      name: "app_one_remote",
      remotes: {
        app_two: "app_two_remote",
        app_three: "app_three_remote"
      },
      exposes: {
        AppContainer: "./src/App"
      },
      shared: ["react", "react-dom", "react-router-dom"]
    }),
    new HtmlWebpackPlugin({
      template: "./public/index.html",
      chunks: ["main"]
    })
  ]
};
```

模块联邦本身是一个普通的 Webpack 插件 ModuleFederationPlugin，插件有几个重要参数：

1. name 当前应用名称，需要全局唯一。

2. remotes 可以将其他项目的 name 映射到当前项目中。

3. exposes 表示导出的模块，只有在此申明的模块才可以作为远程依赖被使用。

4. shared 是非常重要的参数，制定了这个参数，可以让远程加载的模块对应依赖改为使用本地项目的 React 或 ReactDOM。

   var a = [0, 1, 2, 3, 4, 5, 6];
   var index = 0, current = 0; 
   for(var i = 0; i < 50; i++) {
       if (index >= a.length) {
           index = 0;
       }
       if ( i % 7 === 0 && i > 1) {
         console.log("current numbers: ", i, a[0]);
       }
       current = a.splice(0, 1);
       a.push(current[0]);
       console.log("current:", a)
       index += 1;
   }

   

   漫反射：

   漫反射数学模型RGB分量表示：`(R2,G2,B2) = (R1,G1,B1) x (R0,G0,B0) x cosθ`
   // 角度值转化为弧度值
   float radian = radians(60.0);
   // reflectedLight的结果是(0.5,0,0)
   vec3 reflectedLight = vec3(1.0,0.0,0.0) * vec3(1.0,0.0,0.0) * cos(radian)

   镜面反射光的颜色 = 几何体表面基色 x 光线颜色 x 视线与反射光线的夹角余弦值<sup>n</sup>

   环境反射光颜色 = 几何体表面基色 x 环境光颜色

   总反射光线 = 漫反射光线 + 镜面反射光线 + 环境反射光线

   在三维笛卡尔坐标系中，可以使用向量(x,y,z)来表示法向量，根据几何体表面的法向量和光线的方向， 就可以求解出光线入射角的余弦值，法向量的点积计算满足下面的公式，
   为了方便计算，着色器语言内置了一个方法dot()用来求解两个向量之间的余弦值,已知向量a1(x1,y1,z1)、a2(x2，y2，z2)执行dot(a1，a2)可以求出两个向量a1、a2的余弦值。

   attribute vec4 apos;//attribute声明vec4类型变量apos
   attribute vec4 a_color;// attribute声明顶点颜色变量
   attribute vec4 a_normal;//顶点法向量变量
   uniform vec3 u_lightColor;// uniform声明平行光颜色变量
   uniform vec3 u_lightPosition;// uniform声明平行光颜色变量
   varying vec4 v_color;//varying声明顶点颜色插值后变量


   WebGL屏幕坐标系、canvas坐标系和WebGL坐标系转换

   <img src="canvas坐标系和WebGL坐标系转换.png" />
   canvas坐标系转为webgl坐标系，webgl的坐标是x[-1, 1]，y[-1, 1]。

   ①获取canvas在浏览器客户区中的坐标
     var x = ev.clientX;
     var y = ev.clientY;
     var rect = ev.target.getBoundingClientRect();

   图中的P点（x,y）为该点在屏幕坐标系下的坐标值；
   图中canvas原点在屏幕坐标系下的坐标值为（a,b），即canvas在屏幕上左上角的位置坐标；
   其中(a,b)坐标中：
     a = rect.left;
     b = rect.top;

   此时求P点在canvas坐标系下的坐标，即将屏幕上的点P转换到cavans坐标系下：
     x' = x-a = x - rect.left;
     y' = y-b = y - rect.top;
   (x - rect.left,y - rect.top)坐标为P点在canvas坐标系下的坐标值；

   ②将canvas坐标转换到webgl坐标系下
   1.首先我们通过图片可知，canvas坐标系的Y轴和webgl的坐标系的Y轴方向是相反的，即在后面的转换过程中，y坐标值要进行取反操作。
   2.通过代码我们可以获取canvas画布的宽和高：
     width = canvas.width;
     height = canvas.height;
   则webgl原点在canvas坐标系中的位置（即canvas的中心点位置）坐标我们可以直接获得为（width/2,height/2）;

   现在我们所得到的数据有：
   P点在canvas坐标系下的坐标值:（x’,y’）->(x - rect.left,y - rect.top)
   canvas的中心点在canvas坐标系下的坐标值：(width/2,height/2)
   下一步，我们将canvas的原点平移到中心点（WebGL坐标系统的原点位于此处）
   此时将canvas原点平移到中心点时，P点的坐标应该变为：
     x'' = x'-width/2
     y'' = y'-height/2
   为了使得canvas平移后坐标系与WebGL坐标系完全一致，还需要对平移后的Y轴进行取反操作，即
     y'' = -1(y'-height/2)
   此时的
   （x'',y''）= (x'-width/2,height/2-y')) = ((x - rect.left)-width/2,height/2-(y - rect.top))

   在对canvas坐标系进行平移、Y轴取反的操作后（此时的canvas坐标系与webgl坐标系原点位置和xy轴方向完全一致)。由于webgl坐标系的坐标区间为-1.0到1.0，所以最后一步我们将x''坐标除以width/2，将y''坐标除以height/2，
   将canvas坐标映射到webgl坐标。
   即P点坐标（x,y）最终转换后的坐标为（x''/(width/2), y''/(height/2)） = ( ((x - rect.left)-width/2)/(width/2),(height/2-(y - rect.top))/(height/2))
   对应结果：
     x'' = ((x - rect.left) - width/2) / (width/2) = ((x - rect.left) - canvas.width/2) / (canvas.width / 2)
     y'' = (height/2 - (y - rect.top))/(height/2) = (canvas.height / 2-(y - rect.top)) / (canvas.height / 2)


   模型围绕一个点运动
   方法一：对方块A，基于世界坐标系平移，再基于自身/局部坐标系旋转，最后基于世界坐标系平移回去。
   方法二：对方块A，基于自身坐标系平移，再基于自身/局部坐标系旋转，最后基于自身坐标系平移回去。

   BufferGeometry 会缓存网格模型，性能要高效点。网格模型生成原理
   1、Geometry 生成的模型是这样的 （代码）-> (CUP 进行数据处理，转化成虚拟3D数据) -> (GPU 进行数据组装，转化成像素点，准备渲染) -> 显示器
   第二次操作时重复走这些流程。
   2、BufferGeometry 生成模型流程 (代码) -> (CUP 进行数据处理，转化成虚拟3D数据) -> (GPU 进行数据组装，转化成像素点，准备渲染) -> (丢入缓存区) -> 显示器
   第二次修改时，通过API直接修改缓存区数据，流程就变成了这样
   (代码) -> (CUP 进行数据处理，转化成虚拟3D数据) -> (修改缓存区数据) -> 显示器
   节约了GPU性能的运算性能

   判断两条线段是否相交？
   https://www.jb51.net/article/90104.htm

   向量叉乘（行列式计算）：向量a（x1，y1），向量b（x2，y2）：
   a x b = |x1, y1| = x1 * y2 - y1 * x2 |x2, y2|
   首先我们要明白一个定理：
   向量a×向量b（×为向量叉乘），若结果小于0，表示向量b在向量a的顺时针方向；
   若结果大于0，表示向量b在向量a的逆时针方向；
   若等于0，表示向量a与向量b平行。（顺逆时针是指两向量平移至起点相连，从某个方向旋转到另一个向量小于180度）。

   https://www.cnblogs.com/tuyang1129/p/9390376.html
   那如何来判断两线段是否相交呢？
   假设有两条线段AB，CD，若AB，CD相交，我们可以确定：
   1.线段AB与CD所在的直线相交，即点A和点B分别在直线CD的两边；
   2.线段CD与AB所在的直线相交，即点C和点D分别在直线AB的两边；
   上面两个条件同时满足是两线段相交的充要条件，所以我们只需要证明点A和点B分别在直线CD的两边，点C和点D分别在直线AB的两边，这样便可以证明线段AB与CD相交了。


   function  judgeIntersect(x1,y1,x2,y2,x3,y3,x4,y4)
   {

       //快速排斥：
       //两个线段为对角线组成的矩形，如果这两个矩形没有重叠的部分，那么两条线段是不可能出现重叠的
       //这里的确如此，这一步是判定两矩形是否相交
       //1.线段ab的低点低于cd的最高点（可能重合）
       //2.cd的最左端小于ab的最右端（可能重合）
       //3.cd的最低点低于ab的最高点（加上条件1，两线段在竖直方向上重合）
       //4.ab的最左端小于cd的最右端（加上条件2，两直线在水平方向上重合）
       //综上4个条件，两条线段组成的矩形是重合的
       //特别要注意一个矩形含于另一个矩形之内的情况
       
       if(!(Math.min(x1,x2) <= Math.max(x3,x4) && Math.min(y3,y4) <= Math.max(y1,y2) && Math.min(x3,x4) <= Math.max(x1,x2) && Math.min(y1,y2) <= Math.max(y3,y4)))
           return false;
       
       //跨立实验：
       //如果两条线段相交，那么必须跨立，就是以一条线段为标准，另一条线段的两端点一定在这条线段的两段
       //也就是说a b两点在线段cd的两端，c d两点在线段ab的两端
       var u,v,w,z
       u=(x3-x1)*(y2-y1)-(x2-x1)*(y3-y1);
       v=(x4-x1)*(y2-y1)-(x2-x1)*(y4-y1);
       w=(x1-x3)*(y4-y3)-(x4-x3)*(y1-y3);
       z=(x2-x3)*(y4-y3)-(x4-x3)*(y2-y3);
       return (u*v<=0.00000001 && w*z<=0.00000001);
   }

   在上面代码中涉及WebGL着色器三维向量vec3和四维向量vec4两种数据类型，比如光线的方向需要xyz三个分量描述，可以使用关键字vec3声明，比如顶点位置的齐次坐标(x,y,z,w), 包含透明度的RGB颜色模型RGBA(r,g,b,a)都需要四个分量描述，可以使用关键字vec4声明。

   算法：判断一个直线是否和一个轮廓相交
   算法：判断一组轮廓是顺时针还是逆时针
   建立多个视图，透视，俯视图，左视图
   建立过个场景
   再物体本身有旋转的情况下，世界坐标和Local坐标怎么平移

2、CSS优化技巧：

#### content-visibility （实验性属性，非所有浏览器支持）

内容可见性，加速渲染：content-visibility，渲染性能可以大幅提升

content-visibility: auto; 默认属性

#### will-change（移动端，所有浏览器支持）

虽然说will-change能提高性能，但这个属性应该被认为是最后的手段，它不是为了过早的优化。只有消退你必须处理性能问题时，你才应该使用它。如果你滥用的话，反而会降低Web的性能。比如：

使用will-change表示该元素在未来会发生变化。

因此，如果你试图将will-change和动画同时使用，它将不会给你带来优化。因此，建议在父元素上使用will-change，在子元素上使用动画。

在实际使用will-change可以记作以下几个规则，即 五可做，三不可做：

在样式表中少用will-change

给will-change足够的时间令其发挥该有的作用

使用<custom-ident>来针对超特定的变化（如，left, opacity等）

如果需要的话，可以JavaScript中使用它（添加和删除）

修改完成后，删除will-change

不要同时声明太多的属性

不要应用在太多元素上

不要把资源浪费在已停止变化的元素上

详细的使用，请参阅：

CSS Will Change Module Level 1

https://www.w3.org/TR/css-will-change-1/

Everything You Need to Know About the CSS will-change Property

https://dev.opera.com/articles/css-will-change-property/

CSS Reference：will-change

https://tympanus.net/codrops/css_reference/will-change/

#### scroll-behavior（所有浏览器支持）

scroll-behavior是CSSOM View Module提供的一个新特性，可以轻易的帮助我们实现丝滑般的滚动效果。该属性可以为一个滚动框指定滚动行为，其他任何的滚动，例如那些由于用户行为而产生的滚动，不受这个属性的影响。

scroll-behavior接受两个值：

auto ：滚动框立即滚动

smooth ：滚动框通过一个用户代理定义的时间段使用定义的时间函数来实现平稳的滚动，用户代理平台应遵循约定，如果有的话

除此之外，其还有三个全局的值：inherit、initial和unset。

使用起来很简单，只需要这个元素上使用scroll-behavior:smooth。因此，很多时候为了让页面滚动更平滑，建议在html中直接这样设置一个样式：

```css
html {
  scroll-behavior:smooth;
}
```

有关于scroll-behavior属性更多的介绍可以再花点时间阅读下面这些文章：

CSSOM View Module:scroll-behavior

CSS-Tricks: scroll-behavior

Native Smooth Scroll behavior

PAGE SCROLLING IN VANILLA JAVASCRIPT

smooth scroll behavior polyfill



3、JavaScript语法糖：

1. #### 含有多个条件的 if 语句

```javascript
//longhand
if (x === 'abc' || x === 'def' || x === 'ghi' || x ==='jkl') {
  //logic
}
可以简写如下：
//shorthand
if (['abc', 'def', 'ghi', 'jkl'].includes(x)) {
  //logic
}
```

2. #### 同时为多个变量赋值

   当我们处理多个变量，并且需要对这些变量赋不同的值，这种缩写法很有用。

```javascript
//Longhand 
let test1, test2, test3;
test1 = 1;
test2 = 2;
test3 = 3;

//Shorthand 
let [test1, test2, test3] = [1, 2, 3];
```

3. #### switch 对应的缩写法

  我们可以把条件值保存在名值对中，基于这个条件使用名值对代替 switch。
```javascript
// Longhand
switch (data) {
  case 1:
    test1();
  break;
  case 2:
    test2();
  break;
  case 3:
    test();
  break;
  // And so on...
}

// Shorthand
var data = {
  1: test1,
  2: test2,
  3: test
};
data[something] && data[something]();
```

4. #### Array.find 缩写法

  当我们需要在一个对象数组中按属性值查找特定对象时，find 方法很有用。
```javascript
const data = [{
        type: 'test1',
        name: 'abc'
    },
    {
        type: 'test2',
        name: 'cde'
    },
    {
        type: 'test1',
        name: 'fgh'
    },
]
function findtest1(name) {
    for (let i = 0; i < data.length; ++i) {
        if (data[i].type === 'test1' && data[i].name === name) {
            return data[i];
        }
    }
}
//Shorthand
filteredData = data.find(data => data.type === 'test1' && data.name === 'fgh');
console.log(filteredData); // { type: 'test1', name: 'fgh' }
```

